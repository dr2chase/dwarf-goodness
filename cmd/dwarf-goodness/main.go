// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"debug/dwarf"
	"fmt"
	"github.com/dr2chase/dwarf-goodness/line_inputs"
	"sort"

	// "github.com/go-delve/delve/pkg/dwarf/op"
	"github.com/go-delve/delve/pkg/proc"
	"os"
	"runtime"
	"unsafe"
)

//go:noinline
func id(x int) int {
	return x
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

type Function struct {
	Name       string
	Entry, End uint64 // same as DW_AT_lowpc and DW_AT_highpc
	offset     dwarf.Offset
	cu         uintptr
}

type pcln struct {
	pc      uint64
	file    string
	name    string
	line    int
	present bool
}

type i2lkey struct {
	file     string
	variable string
}

type sortedLineMap struct {
	m map[i2lkey][]*pcln
}

var fileCache = map[string]*sortedLineMap{}

func getFile(bi *proc.BinaryInfo, path string) *sortedLineMap {
	if r, cached := fileCache[path]; cached {
		return r
	}
	line2inputs := line_inputs.ReadFile(path)

	sortedLines := line_inputs.SortDomain(line2inputs)

	input2Lines := make(map[i2lkey][]*pcln)

	line2pcs := bi.AllPCsForFileLines(path, sortedLines)

	for _, line := range sortedLines {
		inputs := line2inputs[line]
		k := i2lkey{file: path}
		for _, pc := range line2pcs[line] {
			for _, input := range inputs.Inputs() {
				k.variable = input
				pclns := input2Lines[k]
				pclns = append(pclns, &pcln{file: path, line: line, name: input, pc: pc})
				input2Lines[k] = pclns
			}
		}
	}
	// Sort the input locations by PC to allow faster checking later.
	for _, v := range input2Lines {
		sort.Slice(v, func(i, j int) bool { // less
			return v[i].pc < v[j].pc
		})
	}
	r := &sortedLineMap{m: input2Lines}
	fileCache[path] = r
	return r
}

var file0 string

func main() {
	bi := proc.NewBinaryInfo(runtime.GOOS, runtime.GOARCH)
	bi.LoadBinaryInfo(os.Args[1], 0, []string{})

	rdr := bi.Images[0].DwarfReader()
	rdr.Seek(0)

	for _, fn := range bi.Functions {
		if fn.Entry == 0 {
			continue
		}
		file, _, _ := bi.PCToLine(fn.Entry)

		if file == "" || file == "<autogenerated>" {
			continue
		}

		if file != file0 {
			_, _ = fmt.Fprintf(os.Stderr, "\n")
		}
		input2Lines := getFile(bi, file)
		if input2Lines.m == nil {
			_, _ = fmt.Fprintf(os.Stderr, "Couldn't read source file %s\n", file)
			continue
		}

		if file != file0 {
			_, _ = fmt.Fprintf(os.Stderr, "File %s: ", file)
			file0 = file
		}

		_, _ = fmt.Fprintf(os.Stderr, ".")

		_fn := (*Function)(unsafe.Pointer(&fn))

		rdr.Seek(_fn.offset)
		rdr.Next() // why?

		seen := make(map[string]bool)

		// Taken from optargorder
		for {
			e, err := rdr.Next()
			if err != nil {
				must(err)
			}
			if e == nil || e.Tag == 0 {
				break
			}
			rdr.SkipChildren()
			if e.Tag != dwarf.TagFormalParameter && e.Tag != dwarf.TagVariable {
				continue
			}

			if e.Val(dwarf.AttrName) == nil {
				continue
			}
			name := e.Val(dwarf.AttrName).(string)

			if seen[name] {
				continue
			}
			seen[name] = true

			pclns := input2Lines.m[i2lkey{file: file, variable: name}]
			if len(pclns) == 0 {
				continue
			}

			pairs, err := bi.LocationCovers(e, dwarf.AttrLocation)
			if len(pairs) == 0 {
				continue
			}

			sort.Slice(pairs, func(i, j int) bool { // less
				return pairs[i][0] < pairs[j][0]
			})

			i, j := 0, 0
			pcln := pclns[i]
			p := pairs[j]

			for {
				if pcln.pc > p[1] {
					j++
					if j >= len(pairs) {
						break
					}
					p = pairs[j]
					continue
				}
				if p[0] <= pcln.pc && pcln.pc <= p[1] {
					pcln.present = true
				}
				i++
				if i >= len(pclns) {
					break
				}
				pcln = pclns[i]
			}
		}
	}
	_, _ = fmt.Fprintf(os.Stderr, "\n")
	_, _ = fmt.Fprintf(os.Stderr, "\n")

	// Report the contents of the file Cache
	total := 0
	present := 0
	for fname, slmap := range fileCache {
		for vname, pclns := range slmap.m {
			ninput := len(pclns)
			npresent := 0
			for _, pcln := range pclns {
				if pcln.present {
					npresent++
				}
			}
			if npresent != ninput {
				fmt.Printf("%s,%s,%d,%d\n", fname, vname, ninput, npresent)
			}
			total += ninput
			present += npresent
		}
	}
	fmt.Printf("Total inputs = %d, total present = %d\n", total, present)
}
