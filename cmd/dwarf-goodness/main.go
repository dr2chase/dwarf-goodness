// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"debug/dwarf"
	"flag"
	"fmt"
	"os"
	"regexp"
	"runtime"
	"sort"
	"unsafe"

	"github.com/dr2chase/dwarf-goodness/line_inputs"
	"github.com/go-delve/delve/pkg/proc"
)

func must(err error) {
	if err != nil {
		panic(err)
	}
}

type Function struct {
	Name       string
	Entry, End uint64 // same as DW_AT_lowpc and DW_AT_highpc
	offset     dwarf.Offset
	cu         uintptr
}

type pcln struct {
	pc       uint64
	fileName string
	varName  string
	funcName string
	line     int
	present  bool
}

type summaryKey struct {
	byFile string
	byFunc string
	byLine int
	byVar  string
}

type summaryValue struct {
	present int
	total   int
}

type summaryRecord struct {
	summaryKey
	summaryValue
}

type i2lkey struct {
	file     string
	variable string
}

type sortedLineMap struct {
	m map[i2lkey][]*pcln
}

var fileCache = map[string]*sortedLineMap{}

func getFile(bi *proc.BinaryInfo, path string, skipVar func(name string) bool) *sortedLineMap {
	if r, cached := fileCache[path]; cached {
		return r
	}
	line2inputs := line_inputs.ReadFile(path)

	sortedLines := line_inputs.SortDomain(line2inputs)

	input2Lines := make(map[i2lkey][]*pcln)

	line2pcs := bi.AllPCsForFileLines(path, sortedLines)

	for _, line := range sortedLines {
		inputs := line2inputs[line]
		k := i2lkey{file: path}
		for _, pc := range line2pcs[line] {
			for _, input := range inputs.Inputs() {
				if skipVar(input) {
					continue
				}
				k.variable = input
				pclns := input2Lines[k]
				pclns = append(pclns, &pcln{fileName: path, line: line, varName: input, pc: pc})
				input2Lines[k] = pclns
			}
		}
	}
	// Sort the input locations by PC to allow faster checking later.
	for _, v := range input2Lines {
		sort.Slice(v, func(i, j int) bool { // less
			return v[i].pc < v[j].pc
		})
	}
	r := &sortedLineMap{m: input2Lines}
	fileCache[path] = r
	return r
}

type regexps []*regexp.Regexp

func (res *regexps) String() string {
	r := "["
	sep := ""
	for _, s := range *res {
		r = r + sep + s.String()
		sep = ", "
	}
	r += "]"
	return r
}
func (res *regexps) Set(s string) error {
	r, err := regexp.Compile(s)
	if err != nil {
		return err
	}
	*res = append(*res, r)
	return nil
}

func (res *regexps) IsBoolFlag() bool {
	return false
}

func main() {
	debug := false
	byFile := false
	byFunc := false
	byVar := false
	byLine := false

	var files []*regexp.Regexp
	var funcs []*regexp.Regexp
	var vars []*regexp.Regexp

	flag.BoolVar(&debug, "debug", debug, "Emit (this program's) debugging output to stderr")
	flag.BoolVar(&byFile, "byfile", byFile, "Split summary by file")
	flag.BoolVar(&byFunc, "byfunc", byFunc, "Split summary by functions")
	flag.BoolVar(&byVar, "byvar", byVar, "Split summary by variables")
	flag.BoolVar(&byLine, "byline", byLine, "Split summary by lines")

	flag.Var((*regexps)(&files), "file", "Limit scan to files (pathnames) matching regexp (may be repeated)")
	flag.Var((*regexps)(&funcs), "func", "Limit scan to functions matching regexp (may be repeated)")
	flag.Var((*regexps)(&vars), "var", "Limit scan to variables matching regexp (may be repeated)")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, `
For a binary, %s reports the number of local-variable inputs to lines
that are present at that line's PC(s) in the debugging information,
and for each summary line prints #inputs, #present, #present/#inputs.
With no -byX options, it prints a single summary line.
(There are still bugs in this reporting.)
`, os.Args[0])
	}

	flag.Parse()

	doit(flag.Arg(0), debug, byFile, byFunc, byLine, byVar, files, funcs, vars)
}

func skip(name string, res []*regexp.Regexp) bool {
	if len(res) == 0 {
		return false
	}
	for _, re := range res {
		if re.MatchString(name) {
			return false
		}
	}
	return true
}

func doit(binaryName string, debug, byFile, byFunc, byLine, byVar bool, files, funcs, vars []*regexp.Regexp) {
	var file0 string

	bi := proc.NewBinaryInfo(runtime.GOOS, runtime.GOARCH)
	bi.LoadBinaryInfo(binaryName, 0, []string{})

	rdr := bi.Images[0].DwarfReader()
	rdr.Seek(0)

	skipVar := func(name string) bool {
		return skip(name, vars)
	}

	for _, fn := range bi.Functions {
		if fn.Entry == 0 {
			continue
		}
		if skip(fn.Name, funcs) {
			continue
		}

		file, _, _ := bi.PCToLine(fn.Entry)

		if file == "" || file == "<autogenerated>" {
			continue
		}

		if skip(file, files) {
			continue
		}

		if file != file0 && debug {
			_, _ = fmt.Fprintf(os.Stderr, "\n")
		}
		input2Lines := getFile(bi, file, skipVar)
		if input2Lines.m == nil {
			_, _ = fmt.Fprintf(os.Stderr, "Couldn't read source file %s\n", file)
			continue
		}

		if file != file0 {
			if debug {
				_, _ = fmt.Fprintf(os.Stderr, "File %s: ", file)
			}
			file0 = file
		}

		if debug {
			_, _ = fmt.Fprintf(os.Stderr, ".")
		}

		_fn := (*Function)(unsafe.Pointer(&fn))
		rdr.Seek(_fn.offset)
		rdr.Next() // why?

		seen := make(map[string]bool)

		// Taken from optargorder
		for {
			e, err := rdr.Next()
			if err != nil {
				must(err)
			}
			if e == nil || e.Tag == 0 {
				break
			}
			rdr.SkipChildren()
			if e.Tag != dwarf.TagFormalParameter && e.Tag != dwarf.TagVariable {
				continue
			}

			if e.Val(dwarf.AttrName) == nil {
				continue
			}
			name := e.Val(dwarf.AttrName).(string)

			if seen[name] {
				continue
			}
			seen[name] = true

			pclns := input2Lines.m[i2lkey{file: file, variable: name}]
			if len(pclns) == 0 {
				continue
			}

			pairs, err := bi.LocationCovers(e, dwarf.AttrLocation)
			if len(pairs) == 0 {
				continue
			}

			sort.Slice(pairs, func(i, j int) bool { // less
				return pairs[i][0] < pairs[j][0]
			})

			i, j := 0, 0
			pcln := pclns[i]
			p := pairs[j]

			for {
				if fn.Entry <= pcln.pc && pcln.pc <= fn.End {
					pcln.funcName = fn.Name
				}
				if pcln.pc > p[1] {
					j++
					if j >= len(pairs) {
						break
					}
					p = pairs[j]
					continue
				}
				if p[0] <= pcln.pc && pcln.pc <= p[1] {
					pcln.present = true
				}
				i++
				if i >= len(pclns) {
					break
				}
				pcln = pclns[i]
			}
		}
	}

	if debug {
		_, _ = fmt.Fprintf(os.Stderr, "\n")
		_, _ = fmt.Fprintf(os.Stderr, "\n")
	}

	summary := make(map[summaryKey]summaryValue)
	// Summarize the contents of the file Cache
	var key summaryKey
	var total summaryRecord
	for fname, slmap := range fileCache {
		if byFile {
			key.byFile = fname
		}

		for vname, pclns := range slmap.m {
			if byVar {
				key.byVar = vname.variable
			}
			for _, pcln := range pclns {
				if byFunc {
					key.byFunc = pcln.funcName
				}
				if byLine {
					key.byLine = pcln.line
				}
				value := summary[key]
				value.total++
				total.total++
				if pcln.present {
					value.present++
					total.present++
				}
				summary[key] = value
			}
		}
	}

	// Now sort into a canonical order
	var ordered []summaryRecord
	for k, v := range summary {
		ordered = append(ordered, summaryRecord{k, v})
	}

	sort.Slice(ordered, func(i, j int) bool { // Less
		oi := &ordered[i]
		oj := &ordered[j]
		if oi.byFile != oj.byFile {
			return oi.byFile < oj.byFile
		}
		if oi.byFunc != oj.byFunc {
			return oi.byFunc < oj.byFunc
		}
		if oi.byLine != oj.byLine {
			return oi.byLine < oj.byLine
		}
		if oi.byVar != oj.byVar {
			return oi.byVar < oj.byVar
		}
		return false // equal
	})

	describe := func(s string, record summaryRecord) {
		fmt.Printf("%s%d, %d, %f\n", s, record.total, record.present, float64(record.present)/float64(record.total))
	}

	n := 0
	for _, record := range ordered {
		var s string
		if byFile {
			s = s + record.byFile + ", "
		}
		if byFunc {
			s = s + record.byFunc + ", "
		}
		if byLine {
			s = s + fmt.Sprintf("%d", record.byLine) + ", "
		}
		if byVar {
			s = s + record.byVar + ", "
		}
		n++
		describe(s, record)
	}
	if n > 1 {
		describe("total, ", total)
	}

}
