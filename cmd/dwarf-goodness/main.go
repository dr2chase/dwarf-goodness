// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"debug/dwarf"
	"fmt"
	"github.com/dr2chase/dwarf-goodness/line_inputs"
	// "github.com/go-delve/delve/pkg/dwarf/op"
	"github.com/go-delve/delve/pkg/proc"
	"os"
	"runtime"
	"unsafe"
)

//go:noinline
func id(x int) int {
	return x
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

type Function struct {
	Name       string
	Entry, End uint64 // same as DW_AT_lowpc and DW_AT_highpc
	offset     dwarf.Offset
	cu         uintptr
}

type pcln struct {
	pc      uint64
	file    string
	name    string
	line    int
	present bool
}

type sortedLineMap struct {
	m map[string][]*pcln
}

var fileCache = map[string]*sortedLineMap{}

func getFile(bi *proc.BinaryInfo, path string) *sortedLineMap {
	if r, cached := fileCache[path]; cached {
		return r
	}
	line2inputs := line_inputs.ReadFile(path)
	sortedLines := line_inputs.SortDomain(line2inputs)
	input2Lines := make(map[string][]*pcln)
	for _, line := range sortedLines {
		inputs := line2inputs[line]
		for _, input := range inputs.Inputs() {
			pclns := input2Lines[input]
			for _, pc := range bi.AllPCsForFileLine(path, line) {
				pclns = append(pclns, &pcln{file: path, line: line, name: input, pc: pc})
			}
			input2Lines[input] = pclns
		}
	}
	r := &sortedLineMap{m: input2Lines}
	fileCache[path] = r
	return r
}

func main() {
	bi := proc.NewBinaryInfo(runtime.GOOS, runtime.GOARCH)
	bi.LoadBinaryInfo(os.Args[1], 0, []string{})

	rdr := bi.Images[0].DwarfReader()
	rdr.Seek(0)

	for _, fn := range bi.Functions {
		if fn.Entry == 0 {
			continue
		}
		file, _, _ := bi.PCToLine(fn.Entry)

		if file == "" || file == "<autogenerated>" {
			continue
		}

		input2Lines := getFile(bi, file)
		if input2Lines.m == nil {
			fmt.Printf("Couldn't read source file %s\n", file)
		}

		_fn := (*Function)(unsafe.Pointer(&fn))

		rdr.Seek(_fn.offset)
		rdr.Next() // why?

		seen := make(map[string]bool)

		// Taken from optargorder
		for {
			e, err := rdr.Next()
			if err != nil {
				must(err)
			}
			if e == nil || e.Tag == 0 {
				break
			}
			rdr.SkipChildren()
			if e.Tag != dwarf.TagFormalParameter && e.Tag != dwarf.TagVariable {
				continue
			}

			if e.Val(dwarf.AttrName) == nil {
				continue
			}
			name := e.Val(dwarf.AttrName).(string)

			if seen[name] {
				continue
			}
			seen[name] = true

			pclns := input2Lines.m[name]
			if len(pclns) == 0 {
				continue
			}

			pairs, err := bi.LocationCovers(e, dwarf.AttrLocation)

			for _, pcln := range pclns {
				for _, p := range pairs {
					fmt.Printf("p[0] = 0x%x, pcln.pc=0x%x, p[1] = 0x%x, \n", p[0], pcln.pc, p[1])
					if p[0] <= pcln.pc && pcln.pc <= p[1] {
						pcln.present = true
					}
				}
			}
		}
	}
	// Report the contents of the file Cache
	total := 0
	present := 0
	for fname, slmap := range fileCache {
		for vname, pclns := range slmap.m {
			ninput := len(pclns)
			npresent := 0
			for _, pcln := range pclns {
				if pcln.present {
					npresent++
				}
			}
			if npresent != ninput {
				fmt.Printf("%s,%s,%d,%d\n", fname, vname, ninput, npresent)
			}
			total += ninput
			present += npresent
		}
	}
	fmt.Printf("Total inputs = %d, total present = %d\n", total, present)
}
